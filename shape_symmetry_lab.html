<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape & Symmetry Lab ‚Äì Draw with a Magic Mirror</title>

    <!-- OpenDyslexic Font for better readability -->
    <link href="https://fonts.cdnfonts.com/css/opendyslexic" rel="stylesheet">

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #ffffff;
            --text-secondary: #b8b8d1;
            --accent-pink: #ff6b9d;
            --accent-purple: #c44fff;
            --accent-blue: #4facfe;
            --accent-cyan: #00f2fe;
            --accent-green: #55efc4;
            --accent-yellow: #ffeaa7;
            --accent-orange: #fdcb6e;
            --accent-red: #ff7675;
            --glow: 0 0 20px rgba(79, 172, 254, 0.5);
            --shadow: 0 10px 40px rgba(0,0,0,0.4);
            --radius: 20px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'OpenDyslexic', 'Comic Sans MS', cursive, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.8;
            letter-spacing: 0.05em;
            color: var(--text-primary);
        }

        /* Animated Background */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
        }

        .music-note {
            position: absolute;
            font-size: 2rem;
            opacity: 0.15;
            animation: floatNote 15s infinite ease-in-out;
        }

        @keyframes floatNote {
            0%, 100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.15; }
            90% { opacity: 0.15; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        /* Hand Cursors */
        .hand-cursor {
            position: fixed;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transition: transform 0.05s ease-out;
            display: none;
        }

        .hand-cursor.left {
            background: radial-gradient(circle, var(--accent-pink) 0%, transparent 70%);
            border: 3px solid var(--accent-pink);
            box-shadow: 0 0 20px var(--accent-pink);
        }

        .hand-cursor.right {
            background: radial-gradient(circle, var(--accent-cyan) 0%, transparent 70%);
            border: 3px solid var(--accent-cyan);
            box-shadow: 0 0 20px var(--accent-cyan);
        }

        .hand-cursor.pressing {
            transform: scale(0.7);
        }

        .hand-cursor.wiggle {
            animation: wiggle 0.4s ease;
        }

        @keyframes wiggle {
            0% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); }
            75% { transform: translateX(-4px); }
            100% { transform: translateX(0); }
        }

        /* Main Container */
        .app-container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 15px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(196, 79, 255, 0.3) 0%, rgba(79, 172, 254, 0.3) 100%);
            border-radius: var(--radius);
            margin-bottom: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, var(--accent-yellow), var(--accent-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 1.1rem;
            color: var(--text-secondary);
        }

        /* Dynamic Navigation Bar */
        .nav-bar {
            position: sticky;
            top: 0;
            z-index: 500;
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-purple) 100%);
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 0 0 var(--radius) var(--radius);
            box-shadow: var(--shadow);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .nav-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        .nav-menu {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .nav-link {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            text-decoration: none;
            display: inline-block;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: white;
            color: var(--accent-blue);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        /* Camera Preview */
        .camera-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid var(--accent-purple);
            box-shadow: var(--glow);
            z-index: 100;
            background: #000;
        }

        .camera-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .camera-preview canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .camera-status {
            position: absolute;
            top: 5px;
            left: 5px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 1.5s infinite;
        }

        .status-dot.active {
            background: #2ecc71;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        /* Instructions Panel */
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px 20px;
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.1);
            max-width: 280px;
            z-index: 100;
        }

        .instructions h4 {
            color: var(--accent-cyan);
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .instructions p {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .instructions p span {
            font-size: 1.2rem;
        }

        /* Level Selector */
        .level-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .level-btn {
            padding: 8px 22px;
            font-size: 0.95rem;
            font-family: inherit;
            background: rgba(255,255,255,0.05);
            color: var(--text-secondary);
            border: 2px solid transparent;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .level-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .level-btn.easy.active {
            background: rgba(85, 239, 196, 0.2);
            color: var(--accent-green);
            border-color: var(--accent-green);
        }

        .level-btn.medium.active {
            background: rgba(253, 203, 110, 0.2);
            color: var(--accent-orange);
            border-color: var(--accent-orange);
        }

        .level-btn.hard.active {
            background: rgba(255, 118, 117, 0.2);
            color: var(--accent-red);
            border-color: var(--accent-red);
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .stat-item {
            padding: 8px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 50px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-item span {
            font-size: 1.2rem;
        }

        /* Sound Toggle */
        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: var(--accent-purple);
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: var(--shadow);
            z-index: 100;
            transition: transform 0.3s ease;
        }

        .sound-toggle:hover {
            transform: scale(1.1);
        }

        /* Game Area */
        .game-container {
            background: rgba(255,255,255,0.05);
            border-radius: var(--radius);
            padding: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            min-height: 650px;
            position: relative;
        }

        .mirror-lab {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .mirror-stage {
            position: relative;
            border-radius: 15px;
            background: radial-gradient(circle at top, rgba(255,255,255,0.08), transparent 60%),
                        radial-gradient(circle at bottom, rgba(255,255,255,0.08), transparent 60%),
                        linear-gradient(180deg, rgba(15,52,96,0.95), rgba(22,33,62,0.95));
            overflow: hidden;
        }

        #drawCanvas {
            width: 100%;
            height: 500px;
            display: block;
        }

        .mirror-label {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.3);
            font-size: 0.85rem;
            color: var(--accent-yellow);
        }

        .mirror-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
        }

        .prompt-text {
            flex: 1 1 200px;
            font-size: 1rem;
            color: var(--text-secondary);
        }

        .prompt-highlight {
            font-size: 1.3rem;
            color: var(--accent-yellow);
        }

        .mirror-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .control-btn {
            padding: 8px 16px;
            font-size: 0.95rem;
            font-family: inherit;
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .control-btn.primary {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            border-color: var(--accent-cyan);
        }

        .control-btn.toggle-active {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
            border-color: var(--accent-green);
            box-shadow: 0 0 15px rgba(85, 239, 196, 0.5);
        }

        .shape-cards {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 6px;
        }

        .shape-card {
            padding: 6px 10px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .shape-card span {
            font-size: 1.1rem;
        }

        .shape-card.active {
            border-color: var(--accent-cyan);
            background: rgba(79,172,254,0.2);
            box-shadow: 0 0 15px rgba(79,172,254,0.5);
        }

        .shape-card:hover {
            transform: translateY(-2px);
        }

        /* Odd One Out (Hard Level) */
        .oddone-lab {
            margin-top: 10px;
        }

        .oddone-title {
            text-align: center;
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .oddone-title strong {
            color: var(--accent-yellow);
        }

        .shape-options-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 6px;
        }

        .shape-option {
            width: 90px;
            height: 90px;
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.25);
            background: rgba(0,0,0,0.45);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-option-symbol {
            font-size: 2.3rem;
        }

        .shape-option-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .shape-option.correct {
            box-shadow: 0 0 20px rgba(85,239,196,1);
            border-color: var(--accent-green);
        }

        .shape-option.wrong {
            box-shadow: 0 0 20px rgba(255,118,117,1);
            border-color: var(--accent-red);
        }

        .hidden {
            display: none !important;
        }

        /* Game Message */
        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            border-radius: var(--radius);
            font-size: 1.8rem;
            font-weight: bold;
            z-index: 2000;
            animation: popIn 0.4s ease;
            display: none;
            text-align: center;
        }

        .game-message.success {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
            color: #fff;
            box-shadow: 0 0 50px var(--accent-green);
        }

        .game-message.error {
            background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
            color: #fff;
            box-shadow: 0 0 50px var(--accent-red);
        }

        .game-message.info {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            color: #fff;
            box-shadow: 0 0 50px var(--accent-purple);
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* Confetti */
        .confetti {
            position: fixed;
            width: 12px;
            height: 12px;
            top: -20px;
            border-radius: 2px;
            animation: confettiFall 3s linear forwards;
            z-index: 4000;
        }

        @keyframes confettiFall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Level Complete Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 50px;
            border-radius: var(--radius);
            text-align: center;
            border: 3px solid var(--accent-purple);
            box-shadow: 0 0 50px var(--accent-purple);
            animation: bounceIn 0.5s ease;
            max-width: 90%;
        }

        @keyframes bounceIn {
            0% { transform: scale(0) rotate(-5deg); }
            50% { transform: scale(1.1) rotate(3deg); }
            100% { transform: scale(1) rotate(0); }
        }

        .modal-content h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--accent-yellow), var(--accent-orange));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-stars {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .modal-score {
            font-size: 1.5rem;
            color: var(--text-secondary);
            margin-bottom: 25px;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .header h1 {
                font-size: 1.7rem;
            }
            .camera-preview {
                width: 160px;
                height: 120px;
            }
            .instructions {
                display: none;
            }
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.4rem;
            }
            .level-btn {
                padding: 6px 14px;
                font-size: 0.85rem;
            }
            .shape-option {
                width: 80px;
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <!-- Dynamic Navigation Bar -->
    <div class="nav-bar">
        <div class="nav-container">
            <div class="nav-title">üìö Learning Games</div>
            <div class="nav-menu" id="navMenu"></div>
        </div>
    </div>

    <!-- Animated Background -->
    <div class="bg-animation" id="bgAnimation"></div>

    <!-- Hand Cursors -->
    <div class="hand-cursor left" id="leftHandCursor"></div>
    <div class="hand-cursor right" id="rightHandCursor"></div>

    <!-- Game Message -->
    <div class="game-message" id="gameMessage"></div>

    <!-- Level Complete Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <h2>‚ú® Symmetry Star! ‚ú®</h2>
            <div class="modal-stars">‚≠ê‚≠ê‚≠ê</div>
            <div class="modal-score">Score: <span id="finalScore">0</span></div>
            <button class="control-btn primary" onclick="nextChallenge()">New Challenge ‚Üí</button>
        </div>
    </div>

    <!-- Sound Toggle -->
    <button class="sound-toggle" id="soundToggle" onclick="toggleSound()">üîä</button>

    <!-- Camera Preview -->
    <div class="camera-preview">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="canvasOverlay"></canvas>
        <div class="camera-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Camera</span>
        </div>
    </div>

    <!-- Instructions -->
    <div class="instructions">
        <h4>ü™û How to Play</h4>
        <p><span>üëÜ</span> Move your hand to move the magic pen</p>
        <p><span>‚úä</span> Pinch = draw or choose a shape</p>
        <p><span>‚¨Ü‚¨á</span> Draw on one side, see mirror on the other</p>
        <p><span>‚å®Ô∏è</span> Press M for mouse mode</p>
    </div>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <h1>üî∑ Shape & Symmetry Lab ‚Äì Magic Mirror</h1>
            <p>Draw on one side, and watch your picture appear on the other side of the mirror line.</p>
        </header>

        <!-- Level Selector -->
        <div class="level-selector">
            <button class="level-btn easy active" onclick="selectLevel('easy')">üü¢ Easy</button>
            <button class="level-btn medium" onclick="selectLevel('medium')">üü° Medium</button>
            <button class="level-btn hard" onclick="selectLevel('hard')">üî¥ Hard</button>
        </div>

        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span>‚≠ê</span> Score: <strong id="scoreDisplay">0</strong>
            </div>
            <div class="stat-item">
                <span>üî•</span> Streak: <strong id="streakDisplay">0</strong>
            </div>
            <div class="stat-item">
                <span>üé®</span> Prompts done: <strong id="promptDisplay">0</strong>
            </div>
            <div class="stat-item">
                <span>üß†</span> Symmetry hits: <strong id="symmetryDisplay">0</strong>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-container">
            <div class="mirror-lab" id="mirrorLab">
                <div class="mirror-stage">
                    <canvas id="drawCanvas"></canvas>
                    <div class="mirror-label" id="mirrorLabel">Magic Mirror Line ‚Äì both sides must look the same!</div>
                </div>

                <div class="mirror-controls">
                    <div class="prompt-text">
                        <span id="promptText">
                            Prompt: <span class="prompt-highlight" id="promptHighlight">Trace the big circle.</span>
                        </span>
                        <div class="shape-cards" id="shapeCards">
                            <!-- Only used in easy level -->
                        </div>
                    </div>
                    <div class="mirror-buttons">
                        <button class="control-btn" id="freeDrawBtn" onclick="toggleFreeDrawMode()">
                            üé® Free Draw: OFF
                        </button>
                        <button class="control-btn" onclick="clearDrawing()">
                            üßΩ Clear
                        </button>
                        <button class="control-btn primary" onclick="nextPrompt()">
                            üîÅ New Prompt
                        </button>
                    </div>
                </div>
            </div>

            <div class="oddone-lab hidden" id="oddOneLab">
                <div class="oddone-title">
                    <strong>Hard Mode:</strong> Tap the shape that is <u>not</u> symmetrical across the middle.
                </div>
                <div class="shape-options-row" id="shapeOptionsRow"></div>
            </div>
        </div>
    </div>

    <script>
        // ==================== DYNAMIC NAVIGATION ====================
        const GAMES_CONFIG = {
            'index.html':            { name: 'üî§ Alphabet & Colors', description: 'Learn letters and colors with drag & drop' },
            'planets.html':          { name: 'ü™ê Planets', description: 'Explore our solar system' },
            'exploring_body.html':   { name: 'üß¨ Body Explorer', description: 'Learn about human body parts' },
            'frost_discovery.html':  { name: '‚ùÑÔ∏è Frost Discovery', description: 'Reveal and learn hidden items' },
            'hand_music.html':       { name: 'üéµ Music Hands', description: 'Learn music with hand gestures' },
            'melt_the_ice.html':     { name: 'üåà Melt the Ice', description: 'Melt ice to discover pictures' },
            'science-lab.html':      { name: 'üß™ Science Lab', description: 'Perform fun experiments' },
            'rhythm_conductor.html': { name: 'ü•Å Rhythm Conductor', description: 'Move to the beat & learn tempo' },
            'recycling_sorter.html': { name: '‚ôªÔ∏è Recycling Sorter', description: 'Sort rubbish into the correct bin' },
            'shape_symmetry_lab.html': { name: 'üî∑ Shape & Symmetry Lab', description: 'Draw shapes with a magic mirror' }
        };

        function initializeNavigation() {
            const navMenu = document.getElementById('navMenu');
            const currentFile = window.location.pathname.split('/').pop() || 'index.html';
            navMenu.innerHTML = '';

            for (const [file, config] of Object.entries(GAMES_CONFIG)) {
                const link = document.createElement('a');
                link.className = 'nav-link';
                link.href = file;
                link.textContent = config.name;
                link.title = config.description;
                if (currentFile === file) link.classList.add('active');
                navMenu.appendChild(link);
            }
        }

        // ==================== CONFIG & STATE ====================
        const CONFIG = {
            pinchThreshold: 0.07,
            smoothingFactor: 0.4,
            soundEnabled: true
        };

        let currentLevel = 'easy';
        let score = 0;
        let streak = 0;
        let promptsDone = 0;
        let symmetryHits = 0;

        let audioCtx = null;

        // Drawing state
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        let canvasCenterX = 0;
        let canvasCenterY = 0;

        let penDown = false;
        let lastDrawPoint = null;
        let firstStrokeTime = null;
        let currentGuide = 'circle'; // circle, square, triangle, heart, butterfly, house
        let freeDrawMode = false; // Toggle for free drawing without guides

        // Odd one out state
        const mirrorLab = document.getElementById('mirrorLab');
        const oddOneLab = document.getElementById('oddOneLab');
        const shapeOptionsRow = document.getElementById('shapeOptionsRow');

        const ODD_TASKS = [
            {
                shapes: [
                    { symbol: '‚ö´', label: 'Circle', symmetrical: true },
                    { symbol: '‚¨õ', label: 'Square', symmetrical: true },
                    { symbol: 'üåô', label: 'Moon', symmetrical: false }
                ]
            },
            {
                shapes: [
                    { symbol: '‚ù§Ô∏è', label: 'Heart', symmetrical: true },
                    { symbol: 'ü¶ã', label: 'Butterfly', symmetrical: true },
                    { symbol: 'üêå', label: 'Snail', symmetrical: false }
                ]
            },
            {
                shapes: [
                    { symbol: 'üî∫', label: 'Triangle', symmetrical: true },
                    { symbol: 'üè†', label: 'House', symmetrical: true },
                    { symbol: '‚òÇÔ∏è', label: 'Umbrella', symmetrical: false }
                ]
            }
        ];
        let currentOddTaskIndex = 0;

        // Prompts
        const PROMPTS = {
            easy: [
                { text: 'Trace the big circle.', guide: 'circle' },
                { text: 'Trace the big square.', guide: 'square' },
                { text: 'Trace the tall triangle.', guide: 'triangle' }
            ],
            medium: [
                { text: 'Can you make a heart?', guide: 'heart' },
                { text: 'Can you make a butterfly?', guide: 'butterfly' },
                { text: 'Draw a house with a roof.', guide: 'house' }
            ]
        };

        const SHAPE_CARDS = [
            { id: 'circle',   emoji: '‚ö™', label: 'Circle' },
            { id: 'square',   emoji: '‚¨õ', label: 'Square' },
            { id: 'triangle', emoji: 'üî∫', label: 'Triangle' }
        ];

        // Hand tracking state
        let hands = {
            left:  { x: 0, y: 0, pressing: false, prevPressing: false },
            right: { x: 0, y: 0, pressing: false, prevPressing: false }
        };

        // ==================== AUDIO ====================
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function toggleSound() {
            CONFIG.soundEnabled = !CONFIG.soundEnabled;
            document.getElementById('soundToggle').textContent = CONFIG.soundEnabled ? 'üîä' : 'üîá';
        }

        function playSoftPing() {
            if (!CONFIG.soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.value = 880;
            const t = audioCtx.currentTime;
            gain.gain.setValueAtTime(0.4, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            osc.start(t);
            osc.stop(t + 0.15);
        }

        function playSuccessJingle() {
            if (!CONFIG.soundEnabled || !audioCtx) return;
            const notes = [523.25, 659.25, 783.99];
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'triangle';
                osc.frequency.value = freq;
                const t = audioCtx.currentTime + i * 0.1;
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
                osc.start(t);
                osc.stop(t + 0.25);
            });
        }

        function playErrorSound() {
            if (!CONFIG.soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sawtooth';
            osc.frequency.value = 200;
            const t = audioCtx.currentTime;
            gain.gain.setValueAtTime(0.4, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
            osc.start(t);
            osc.stop(t + 0.25);
        }

        function speak(text, rate = 0.9) {
            if (!CONFIG.soundEnabled) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = rate;
            utterance.pitch = 1.05;
            utterance.lang = 'en-US';
            speechSynthesis.speak(utterance);
        }

        // ==================== UI HELPERS ====================
        function updateStats() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('streakDisplay').textContent = streak;
            document.getElementById('promptDisplay').textContent = promptsDone;
            document.getElementById('symmetryDisplay').textContent = symmetryHits;
        }

        function showMessage(text, type) {
            const msg = document.getElementById('gameMessage');
            msg.textContent = text;
            msg.className = `game-message ${type}`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; }, 1400);
        }

        function showLevelComplete() {
            document.getElementById('finalScore').textContent = score;
            document.getElementById('modalOverlay').style.display = 'flex';
            createConfetti();
        }

        function nextChallenge() {
            document.getElementById('modalOverlay').style.display = 'none';
            if (currentLevel === 'hard') {
                setupOddOneTask();
            } else {
                nextPrompt(true);
            }
        }

        function createConfetti() {
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#e91e63', '#00bcd4'];
            for (let i = 0; i < 60; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 2 + 's';
                confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                document.body.appendChild(confetti);
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        // ==================== CANVAS & GUIDES ====================
        function resizeCanvas() {
            const rect = drawCanvas.getBoundingClientRect();
            drawCanvas.width = rect.width * window.devicePixelRatio;
            drawCanvas.height = rect.height * window.devicePixelRatio;
            drawCtx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);

            canvasCenterX = rect.width / 2;
            canvasCenterY = rect.height / 2;

            drawGuide();
        }

        window.addEventListener('resize', resizeCanvas);

        function clearDrawing() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            drawGuide();
            penDown = false;
            lastDrawPoint = null;
            firstStrokeTime = null;
        }

        function toggleFreeDrawMode() {
            freeDrawMode = !freeDrawMode;
            const btn = document.getElementById('freeDrawBtn');
            const label = document.getElementById('mirrorLabel');
            if (freeDrawMode) {
                btn.classList.add('toggle-active');
                btn.textContent = 'üé® Free Draw: ON';
                label.textContent = '‚ú® Free Drawing Mode ‚Äì Create anything with symmetry! ‚ú®';
                speak('Free drawing mode on. Draw anything you want!');
            } else {
                btn.classList.remove('toggle-active');
                btn.textContent = 'üé® Free Draw: OFF';
                label.textContent = 'Magic Mirror Line ‚Äì both sides must look the same!';
                speak('Free drawing mode off. Following prompts.');
            }
            clearDrawing();
        }

        function drawGuide() {
            const w = drawCanvas.width / window.devicePixelRatio;
            const h = drawCanvas.height / window.devicePixelRatio;
            drawCtx.clearRect(0, 0, w, h);

            // background subtle grid
            drawCtx.strokeStyle = 'rgba(255,255,255,0.06)';
            drawCtx.lineWidth = 1;
            for (let x = 0; x < w; x += 40) {
                drawCtx.beginPath();
                drawCtx.moveTo(x, 0);
                drawCtx.lineTo(x, h);
                drawCtx.stroke();
            }
            for (let y = 0; y < h; y += 40) {
                drawCtx.beginPath();
                drawCtx.moveTo(0, y);
                drawCtx.lineTo(w, y);
                drawCtx.stroke();
            }

            // mirror line
            drawCtx.strokeStyle = 'rgba(255,255,255,0.9)';
            drawCtx.lineWidth = 3;
            drawCtx.setLineDash([8, 8]);
            drawCtx.beginPath();
            drawCtx.moveTo(canvasCenterX, 0);
            drawCtx.lineTo(canvasCenterX, h);
            drawCtx.stroke();
            drawCtx.setLineDash([]);

            drawCtx.lineWidth = 4;
            drawCtx.lineCap = 'round';

            // guide shapes - only draw if not in free draw mode
            if (!freeDrawMode) {
                drawCtx.strokeStyle = 'rgba(255,255,255,0.35)';

                if (currentLevel === 'easy') {
                    drawSimpleGuide(currentGuide);
                } else if (currentLevel === 'medium') {
                    drawSymmetryGuide(currentGuide);
                }
            }
        }

        function drawSimpleGuide(type) {
            const w = drawCanvas.width / window.devicePixelRatio;
            const h = drawCanvas.height / window.devicePixelRatio;

            if (type === 'circle') {
                const r = Math.min(w, h) * 0.3;
                drawCtx.beginPath();
                drawCtx.arc(canvasCenterX, canvasCenterY, r, 0, Math.PI * 2);
                drawCtx.stroke();
            } else if (type === 'square') {
                const size = Math.min(w, h) * 0.45;
                const x = canvasCenterX - size / 2;
                const y = canvasCenterY - size / 2;
                drawCtx.strokeRect(x, y, size, size);
            } else if (type === 'triangle') {
                const base = Math.min(w, h) * 0.5;
                const height = Math.min(w, h) * 0.45;
                const x1 = canvasCenterX - base / 2;
                const x2 = canvasCenterX + base / 2;
                const y1 = canvasCenterY + height / 2;
                const y2 = canvasCenterY - height / 2;
                drawCtx.beginPath();
                drawCtx.moveTo(x1, y1);
                drawCtx.lineTo(x2, y1);
                drawCtx.lineTo(canvasCenterX, y2);
                drawCtx.closePath();
                drawCtx.stroke();
            }
        }

        function drawSymmetryGuide(type) {
            const w = drawCanvas.width / window.devicePixelRatio;
            const h = drawCanvas.height / window.devicePixelRatio;

            if (type === 'heart') {
                const r = Math.min(w, h) * 0.18;
                const yOffset = -10;
                drawCtx.beginPath();
                drawCtx.moveTo(canvasCenterX, canvasCenterY + r + 40 + yOffset);
                drawCtx.bezierCurveTo(
                    canvasCenterX + r * 2, canvasCenterY + r / 2 + yOffset,
                    canvasCenterX + r, canvasCenterY - r + yOffset,
                    canvasCenterX, canvasCenterY - r / 3 + yOffset
                );
                drawCtx.bezierCurveTo(
                    canvasCenterX - r, canvasCenterY - r + yOffset,
                    canvasCenterX - r * 2, canvasCenterY + r / 2 + yOffset,
                    canvasCenterX, canvasCenterY + r + 40 + yOffset
                );
                drawCtx.stroke();
            } else if (type === 'butterfly') {
                const wingW = Math.min(w, h) * 0.18;
                const wingH = Math.min(w, h) * 0.25;
                // body
                drawCtx.beginPath();
                drawCtx.moveTo(canvasCenterX, canvasCenterY - wingH * 0.6);
                drawCtx.lineTo(canvasCenterX, canvasCenterY + wingH * 0.6);
                drawCtx.stroke();

                // right wings (mirrored visually)
                drawCtx.beginPath();
                drawCtx.ellipse(
                    canvasCenterX + wingW * 0.7, canvasCenterY - wingH * 0.2,
                    wingW, wingH * 0.7, 0, 0, Math.PI * 2
                );
                drawCtx.stroke();
                drawCtx.beginPath();
                drawCtx.ellipse(
                    canvasCenterX + wingW * 0.7, canvasCenterY + wingH * 0.4,
                    wingW * 0.9, wingH * 0.6, 0, 0, Math.PI * 2
                );
                drawCtx.stroke();

                // left wings
                drawCtx.beginPath();
                drawCtx.ellipse(
                    canvasCenterX - wingW * 0.7, canvasCenterY - wingH * 0.2,
                    wingW, wingH * 0.7, 0, 0, Math.PI * 2
                );
                drawCtx.stroke();
                drawCtx.beginPath();
                drawCtx.ellipse(
                    canvasCenterX - wingW * 0.7, canvasCenterY + wingH * 0.4,
                    wingW * 0.9, wingH * 0.6, 0, 0, Math.PI * 2
                );
                drawCtx.stroke();
            } else if (type === 'house') {
                const size = Math.min(w, h) * 0.4;
                const baseY = canvasCenterY + size * 0.25;
                const leftX = canvasCenterX - size / 2;
                const rightX = canvasCenterX + size / 2;
                const roofTopY = canvasCenterY - size * 0.35;

                drawCtx.beginPath();
                drawCtx.moveTo(leftX, baseY);
                drawCtx.lineTo(rightX, baseY);
                drawCtx.lineTo(rightX, canvasCenterY - size * 0.05);
                drawCtx.lineTo(leftX, canvasCenterY - size * 0.05);
                drawCtx.closePath();
                drawCtx.stroke();

                drawCtx.beginPath();
                drawCtx.moveTo(leftX, canvasCenterY - size * 0.05);
                drawCtx.lineTo(canvasCenterX, roofTopY);
                drawCtx.lineTo(rightX, canvasCenterY - size * 0.05);
                drawCtx.stroke();
            }
        }

        function startDraw(x, y) {
            const rect = drawCanvas.getBoundingClientRect();
            const localX = x - rect.left;
            const localY = y - rect.top;
            if (localX < 0 || localX > rect.width || localY < 0 || localY > rect.height) return;

            penDown = true;
            lastDrawPoint = { x: localX, y: localY };
            if (!firstStrokeTime) {
                firstStrokeTime = performance.now();
                // after a little bit, give a hint about symmetry
                setTimeout(() => {
                    if (firstStrokeTime) {
                        symmetryHits++;
                        score += 10;
                        updateStats();
                        speak('Look, both sides move together. Both sides must look the same.');
                    }
                }, 2500);
            }
        }

        function moveDraw(x, y) {
            if (!penDown || !lastDrawPoint) return;
            const rect = drawCanvas.getBoundingClientRect();
            const localX = x - rect.left;
            const localY = y - rect.top;
            if (localX < 0 || localX > rect.width || localY < 0 || localY > rect.height) {
                endDraw();
                return;
            }

            drawSegment(lastDrawPoint.x, lastDrawPoint.y, localX, localY);
            lastDrawPoint = { x: localX, y: localY };
        }

        function endDraw() {
            penDown = false;
            lastDrawPoint = null;
        }

        function drawSegment(x1, y1, x2, y2) {
            drawCtx.strokeStyle = '#ffeaa7';
            drawCtx.lineWidth = 4;
            drawCtx.lineCap = 'round';

            // main stroke
            drawCtx.beginPath();
            drawCtx.moveTo(x1, y1);
            drawCtx.lineTo(x2, y2);
            drawCtx.stroke();

            // mirrored stroke across vertical center
            const mx1 = canvasCenterX + (canvasCenterX - x1);
            const mx2 = canvasCenterX + (canvasCenterX - x2);

            drawCtx.beginPath();
            drawCtx.moveTo(mx1, y1);
            drawCtx.lineTo(mx2, y2);
            drawCtx.stroke();
        }

        // ==================== PROMPTS & LEVELS ====================
        const promptHighlightEl = document.getElementById('promptHighlight');
        const shapeCardsContainer = document.getElementById('shapeCards');

        function selectLevel(level) {
            currentLevel = level;
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.classList.contains(level)) btn.classList.add('active');
            });

            // reset some stats but keep total score
            streak = 0;
            promptsDone = 0;
            symmetryHits = 0;
            updateStats();

            if (currentLevel === 'hard') {
                mirrorLab.classList.add('hidden');
                oddOneLab.classList.remove('hidden');
                speak('Hard level. Find the shape that is not symmetrical.');
                setupOddOneTask();
            } else {
                mirrorLab.classList.remove('hidden');
                oddOneLab.classList.add('hidden');
                setupShapeCards();
                nextPrompt(true);
                speak(currentLevel === 'easy'
                    ? 'Easy level. Trace simple shapes. The mirror will help you.'
                    : 'Medium level. Draw hearts, butterflies, and houses. Make both sides match.');
            }

            clearDrawing();
        }

        function nextPrompt(fromLevelChange = false) {
            const list = PROMPTS[currentLevel];
            if (!list) return;
            const idx = Math.floor(Math.random() * list.length);
            const prompt = list[idx];
            currentGuide = prompt.guide;
            promptHighlightEl.textContent = prompt.text;
            calloutSymmetryHint(prompt.text);
            clearDrawing();
            if (!fromLevelChange) {
                promptsDone++;
                score += 10;
                updateStats();
                if (promptsDone > 0 && promptsDone % 5 === 0) {
                    showLevelComplete();
                    playSuccessJingle();
                }
            }
        }

        function calloutSymmetryHint(promptText) {
            speak(promptText);
            setTimeout(() => {
                speak('Remember, both sides must look the same.', 0.85);
            }, 1200);
        }

        function setupShapeCards() {
            shapeCardsContainer.innerHTML = '';
            if (currentLevel !== 'easy') return;

            SHAPE_CARDS.forEach(card => {
                const el = document.createElement('div');
                el.className = 'shape-card';
                el.dataset.shape = card.id;

                const emoji = document.createElement('span');
                emoji.textContent = card.emoji;
                const label = document.createElement('span');
                label.textContent = card.label;

                el.appendChild(emoji);
                el.appendChild(label);

                el.addEventListener('click', () => {
                    document.querySelectorAll('.shape-card').forEach(c => c.classList.remove('active'));
                    el.classList.add('active');
                    currentGuide = card.id;
                    promptHighlightEl.textContent = `Trace the ${card.label.toLowerCase()}.`;
                    clearDrawing();
                    speak(`Now trace the ${card.label.toLowerCase()}.`);
                });

                shapeCardsContainer.appendChild(el);
            });
        }

        // ==================== ODD ONE OUT (HARD) ====================
        function setupOddOneTask() {
            shapeOptionsRow.innerHTML = '';
            const task = ODD_TASKS[currentOddTaskIndex % ODD_TASKS.length];
            currentOddTaskIndex++;

            task.shapes.forEach((shape, idx) => {
                const el = document.createElement('div');
                el.className = 'shape-option';
                el.dataset.symmetrical = shape.symmetrical ? 'true' : 'false';

                const sym = document.createElement('div');
                sym.className = 'shape-option-symbol';
                sym.textContent = shape.symbol;

                const lab = document.createElement('div');
                lab.className = 'shape-option-label';
                lab.textContent = shape.label;

                el.appendChild(sym);
                el.appendChild(lab);

                el.addEventListener('click', () => {
                    handleOddSelection(el);
                });

                shapeOptionsRow.appendChild(el);
            });

            speak('Can you find the shape that is not symmetrical? Both sides must look the same.');
        }

        function handleOddSelection(el) {
            const isSym = el.dataset.symmetrical === 'true';
            if (!isSym) {
                el.classList.add('correct');
                score += 20;
                streak++;
                symmetryHits++;
                updateStats();
                speak('Yes, that one is not symmetrical. Good spotting!');
                playSuccessJingle();
                showMessage('üéâ Correct!', 'success');
                setTimeout(() => showLevelComplete(), 900);
            } else {
                el.classList.add('wrong');
                streak = 0;
                updateStats();
                speak('Not quite. This shape can be split into two matching sides.');
                playErrorSound();
                showMessage('‚ùå Try a different shape', 'error');
                setTimeout(() => el.classList.remove('wrong'), 800);
            }
        }

        function handleTap(x, y) {
            const elements = document.elementsFromPoint(x, y);
            for (const el of elements) {
                if (el.classList && el.classList.contains('shape-option')) {
                    handleOddSelection(el);
                    return;
                }
            }
        }

        // ==================== MEDIAPIPE HANDS ====================
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasOverlay');
        const canvasCtx = canvasElement.getContext('2d');
        const leftHandCursor = document.getElementById('leftHandCursor');
        const rightHandCursor = document.getElementById('rightHandCursor');
        const statusDot = document.getElementById('statusDot');

        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17]
        ];

        const mpHands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        mpHands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        mpHands.onResults(onResults);

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    statusDot.classList.add('active');
                    detectLoop();
                };
            } catch (err) {
                console.error('Camera error:', err);
                document.getElementById('statusText').textContent = 'No cam';
            }
        }

        async function detectLoop() {
            if (videoElement.readyState >= 2) {
                await mpHands.send({ image: videoElement });
            }
            requestAnimationFrame(detectLoop);
        }

        function onResults(results) {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            let leftDetected = false;
            let rightDetected = false;

            if (results.multiHandLandmarks && results.multiHandedness) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handedness = results.multiHandedness[index].label;

                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                        color: handedness === 'Left' ? '#ff6b9d' : '#00f2fe',
                        lineWidth: 2
                    });
                    drawLandmarks(canvasCtx, landmarks, {
                        color: handedness === 'Left' ? '#ff6b9d' : '#00f2fe',
                        lineWidth: 1,
                        radius: 3
                    });

                    if (handedness === 'Left') {
                        rightDetected = true;
                        processHand(landmarks, 'right');
                    } else {
                        leftDetected = true;
                        processHand(landmarks, 'left');
                    }
                });
            }

            if (!leftDetected) {
                leftHandCursor.style.display = 'none';
                hands.left.pressing = false;
            }
            if (!rightDetected) {
                rightHandCursor.style.display = 'none';
                hands.right.pressing = false;
            }
        }

        function processHand(landmarks, side) {
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];

            const rawX = (1 - indexTip.x) * window.innerWidth;
            const rawY = indexTip.y * window.innerHeight;

            hands[side].x += (rawX - hands[side].x) * CONFIG.smoothingFactor;
            hands[side].y += (rawY - hands[side].y) * CONFIG.smoothingFactor;

            const cursor = side === 'left' ? leftHandCursor : rightHandCursor;
            cursor.style.display = 'block';
            cursor.style.left = (hands[side].x - 25) + 'px';
            cursor.style.top = (hands[side].y - 25) + 'px';

            const pinchDistance = Math.sqrt(
                Math.pow(indexTip.x - thumbTip.x, 2) +
                Math.pow(indexTip.y - thumbTip.y, 2) +
                Math.pow(indexTip.z - thumbTip.z, 2)
            );

            hands[side].prevPressing = hands[side].pressing;
            hands[side].pressing = pinchDistance < CONFIG.pinchThreshold;

            cursor.classList.toggle('pressing', hands[side].pressing);

            const x = hands[side].x;
            const y = hands[side].y;

            // Use right hand as main drawing hand
            if (side === 'right') {
                if (currentLevel === 'hard') {
                    // Hard mode: tap selection, no drawing
                    if (hands[side].pressing && !hands[side].prevPressing) {
                        handleTap(x, y);
                    }
                } else {
                    handleHandDrawing(x, y, hands[side].pressing, hands[side].prevPressing);
                }
            }
        }

        function handleHandDrawing(x, y, pressing, prevPressing) {
            if (pressing && !prevPressing) {
                startDraw(x, y);
            } else if (pressing && prevPressing) {
                moveDraw(x, y);
            } else if (!pressing && prevPressing) {
                endDraw();
            }
        }

        // ==================== MOUSE FALLBACK ====================
        let mouseMode = false;
        let mouseDown = false;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'm' || e.key === 'M') {
                mouseMode = !mouseMode;
                alert('Mouse mode: ' + (mouseMode ? 'ON' : 'OFF'));
            }
        });

        drawCanvas.addEventListener('mousedown', (e) => {
            if (!mouseMode || currentLevel === 'hard') return;
            mouseDown = true;
            startDraw(e.clientX, e.clientY);
        });

        document.addEventListener('mousemove', (e) => {
            if (!mouseMode) return;
            rightHandCursor.style.display = 'block';
            rightHandCursor.style.left = (e.clientX - 25) + 'px';
            rightHandCursor.style.top = (e.clientY - 25) + 'px';

            if (mouseDown && currentLevel !== 'hard') {
                moveDraw(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (!mouseMode) return;
            if (currentLevel === 'hard') {
                handleTap(e.clientX, e.clientY);
            } else {
                endDraw();
            }
            mouseDown = false;
        });

        // ==================== BACKGROUND ANIMATION ====================
        function createMusicNotes() {
            const container = document.getElementById('bgAnimation');
            const notes = ['‚óá', '‚¨õ', 'üî∫', '‚ö™', 'üí†', 'ü™û'];
            for (let i = 0; i < 15; i++) {
                const note = document.createElement('div');
                note.className = 'music-note';
                note.textContent = notes[Math.floor(Math.random() * notes.length)];
                note.style.left = Math.random() * 100 + 'vw';
                note.style.animationDelay = Math.random() * 15 + 's';
                note.style.animationDuration = (Math.random() * 10 + 10) + 's';
                container.appendChild(note);
            }
        }

        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', () => {
            initializeNavigation();
            createMusicNotes();
            setupCamera();
            resizeCanvas();
            setupShapeCards();
            nextPrompt(true);
            updateStats();

            // Init audio on first interaction
            document.addEventListener('click', () => { initAudio(); }, { once: true });
            document.addEventListener('touchstart', () => { initAudio(); }, { once: true });
        });
    </script>
</body>
</html>
